## 설계와 아키텍처란 ?

- 아키텍처 : 저수준의 세부사항과는 분리된 고수준의 무언가
- 설계 : 저수준의 구조 또는 결정사항

이 둘은 단절 없이 이어진 직물과 같으며, 이를 통해 대상 시스템의 구조를 정의한다.
고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐이다.

### 목표

- 빨리 가는 유일한 방법은 제대로 가는 것이다.
- 시스템의 수명이 다할 때까지 낮게 유지할 수 있는 것이 좋은 설계이다.
- 궁극적인 목표는 필요한 시스템을 만들고, 유지보수하는데 투입되는 인력을 최소화하는 것이다.

<br>

## 두 가지 가치에 대한 이야기

- 소프트웨어의 가치로 행위와 아키텍처가 있다.
- 아키텍처를 위해 투쟁해야한다.
- 개발자는 소프트웨어를 안전하게 보호해야할 의무가 있다. 이를 위해서는 아키텍처가 중요하다.
- 시스템 개발비용이 많이 들고, 시스템 변경이 불가능한 상황이라면 아키텍처를 위해 충분히 투쟁하지 않았다는 뜻이다.

<br>

## 구조적 프로그래밍

- 다익스트라는 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있음을 발견함
- if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 goto문을 사용하는 것이 좋은 방식임을 발견함
  - goto문 : goto 문은 여러 프로그래밍 언어에 등장하는 프로그램의 어느 부분에서 행번호나 레이블이 있는 다른 부분으로 건너뛸 때(one-way transfer) 사용하는 명령어
- 이러한 제어 구조만 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해보였음
- 순차, 분기, 반복이라는 3가지 구조만으로 표현할 수 있음을 증명함
- 결과적으로는 goto 문을 쓰는 것이 없어지고, 우리는 구조적 프로그래머가 되었으며 뒤에가서 배울 객체지향 언어와 함수형 패러다임을 혼용하는 개발자이다.

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있게 되었다.
- 구조적 분석이나 구조적 설계가 인기를 끌었고, 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있었고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있음

### 테스트

- 구조적 프로그래밍은 반증 가능한 단위를 만들어낼 수 있다.
- 아무런 제약없는 goto문장은 반증 가능한 단위를 만들어낼 수 없기에 현대적 언어에서 지원되지 않는다.
- _테스트는 버그가 있음을 보여줄뿐, 버그가 없음을 보여주지는 않는다_.
- 구조적 프로그래밍을 통하여 반증 가능한 단위를 만들고, 충분하게 반증을 하여 목표에 부합하게 만드는 것임.

<br>

## 객체 지향 프로그래밍

- 객체 지향(Object-Oriented) 프로그래밍은 캡슐화, 상속, 다형성 본질이 있다.

### 1. 캡슐화

- 데이터와 메서드를 하나의 단위로 묶어 외부에서 직접 접근하지 못하도록 보호하는 개념입니다.

```java
public class Person {
	// 멤버 변수를 사용하여 age 접근 제한
	private int age;

	// 접근은 제한하지만, 데이터를 읽고 변경하기 위해서 getter, setter 함수를 쓴다.
	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		if (age >= 0) {
			this.age = age;
		}
	}
}
```

- 객체지향을 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것이 틀림없다.
- 자바스크립트 예제 : https://alcohol-dev.tistory.com/1

### 2.상속

- 기본클래스(base class)의 특징을 파생클래스(derived class)가 상속받는 개념이다.
- 객체지향 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 확실히 제공했다. (0.5점)
- 자바스크립트에서는 프로토타입 형식으로 구현이 가능하다.

### 3.다형성

- 다형성이란 특정 기능을 선언(설계)부분과 구현(동작)부분으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능이다.
- 다형성 역시 함수를 가리키는 포인터를 응용한 것 뿐이며, 객체지향 언어가 새롭게 만든 것은 전혀 없다.
- 대신 다형성을 좀 더 안전하고 편리하게 사용할 수 있도록 해주었다.

### 의존성 역전

- 인터페이스를 통해 소스 코드 의존성이 제어 흐름과 반대가 될 수 있다. 이를 의존성 역전이라고 한다.
- 객체지향 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
- 이는 코드의 흐름이 Top -> Bottom 형식으로 제어가 되는데, 반대로 Bottom -> Top 으로도 제어가 가능하다는 뜻이다.
- 이를 통해 상위 수준 모듈이 변경되어도 하위 수준 모듈에 영향을 덜 주고, 코드의 재사용성과 유지 보수성을 향상시킬 수 있습니다.

<br>

## 함수형 프로그래밍

- 일반적으로 자바와 같은 프로그램은 가변 변수를 사용하여, 프로그램 실행 중에 상태가 변할 수 있지만 함수형 프로그래밍은 가변 변수가 없다.
- 변수가 한번 초기화되면 절대 변하지 않는다는 것을 말한다.

### 불변성과 아키텍처

- 경쟁 조건, 교착 상태, 동시성 문제는 모두 가변 변수로 인해 발생한다.
- 불변성이 가능하다면, 대체로 긍정적이지만 이는 저장 공간이 무한하고 프로세서의 속도가 무한하다는 전제가 있어야한다.
- 자원은 무한이 아니기 때문에, 일종의 타협이 필요하다.

### 가변성 분리

- 불변성과 관련해 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 가변 변수는 사용되지 않는다.
- **현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트는 최소한으로 해야한다.**

### 이벤트 소싱

- 이벤트 소싱이란 발생한 이벤트를 저장하는 전략이다. 그러면 사용자 삭제/등록도 상태 변경이 아닌 삭제 이벤트, 등록 이벤트로 저장이 된다.
- 이벤트 소싱은 데이터의 변경과 삭제가 없기 때문에, 동시성 문제가 거의 일어나지 않는다.

<br>

## 결론

- 3가지 패러다임 요약
  - 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 부과되는 규율
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
  - 함수형 프로그래밍은 변수 할당에 부과되는 규율
- 지난 시간동안 우리가 배운 것은 해서 안되는 것들이며, 결국 소프트웨어는 급격히 발전하는 기술이 아니다.
- 소프트웨어는 순차, 분기, 반복, 참조 그 이상 이하도 아니다.

## 참고

- https://velog.io/@turtle601/JS-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EB%A5%BC-%EC%9C%84%ED%95%B4%EC%84%9C-SOLID-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4#-dip%EC%9D%98%EC%A1%B4-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99
- https://velog.io/@ssulv3030/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%83%81%EC%86%8D%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%A0%EA%B9%8C
