# 컴포넌트 응집도

### REP : 재사용 / 릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다.

아키텍처의 관점에서 단일 컴포넌트는 응집성 높은 클래스 & 모듈로 구성되어야 한다.

즉, 공유하는 중요한 테마나 목적이 같은 것끼리 구성되어야한다는 뜻이다.

### CCP : 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이 원칙은 단일 책임 원칙 SRP 를 컴포넌트 관점에서 다시 쓴 것이다.
CCP에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.

애플리케이션 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기 보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

따라서 CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳(하나의 컴포넌트로)으로 묶을 것을 권한다.

### CRP : 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

공통 재사용 원칙 CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다. 같이 재사용되는 경향이 있는 클래스와 모듈들을 같은 컴포넌트에 포함해야 한다고 말한다.

재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.

예시) container와 iterator - 이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다. 따라서 동일한 컴포넌트에 위치해야한다.

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에 의존성이 생긴다.

사용하는 클래스에서 사용되는 클래스에서 단 하나의 클래스만 사용한다고 해도 의존성은 약해지지 않는다.

이런 의존성으로 인해 사용되는 컴포넌트가 변경될 때 마다 사용하는 컴포넌트도 변경해야할 가능성이 높다.

따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

**CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.**

<ISP와의 관계>

CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.
ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다.

CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 한다.

### 컴포넌트 응집도에 대한 균형 다이어그램

![Alt text](image.png)

- REP, CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미침
- CCP, REP에만 중점을 두면, 불필요한 릴리스가 너무 빈번해짐
  프로젝트 초기에는 CCP가 REP보다 훨씬 중요한데, 이는 개발 가능성이 재사용성보다 더욱 중요하기 때문입니다.

프로젝트가 성숙하고 해당 프로젝트로 부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동해 갑니다.

즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다는 뜻입니다.

# 컴포넌트 결합

### ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

'숙취증후군' : 내가 의존하고 있는 무언가가 수정이 되어서 작동하던 프로그램이 돌아가지 않는다. 😵

이를 해결하기 위한 2가지 방안이 있다.

1. 주단위 빌드
2. 의존성 비순환 원칙

#### 주 단위 빌드

- 5일 중 4일 동안 개발자가 각자 개발하고 하루에 몰아서 통합 및 빌드를 진행한다.
- 장점 : 빠른 피드백, 고립된 환경에서의 개발
- 단점 : 통합과 테스트를 수행하기 점점 어려워 짐.

#### 의존성 비순환 원칙

개발환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것입니다.
이를 통해 컴포넌트는 개별 개발자 또는 개발팀이 책임질 수 있는 단위가 됩니다. 이후 릴리스 번호를 부여하여 다른 팀에서 사용할 수 있도록 만듭니다.

그런 다음 각 개발팀은 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정하고, 다른 팀에서는 릴리스 된 버전을 사용하면 됩니다.

새로운 버전이 나와도 다른 팀들은 해당 버전으로 통합할지는 자유롭게 결정할 수 있으므로 컴포넌트의 변경이 즉각적으로 다른 팀들에게 영향을 주지 않습니다.

하지만 이렇게 사용하기 위해서는 의존성 구조를 잘 관리 하여야 합니다. 즉, 순환되는 구조가 없도록 잘 관리되어야 합니다.

![Alt text](image2.png)

위의 그림은 '비순환 방향 그래프'로 어느 컴포넌트에서 시작하더라도 최초 컴포넌트로 돌아갈 수 없는 구조입니다.
위와 같은 구조의 릴리즈는 상향식으로 진행하면 됩니다.

#### 순환이 컴포넌트 의존성에 미치는 영향

![Alt text](image-1.png)
위 그림에서 Entities에 포함된 클래스 하나가 Authorize에 포함된 클래스 하나를 사용하도록 변경하였습니다.

이떄 순환 의존성이 발생하게 됩니다.
만약 Database를 릴리즈하려고 하면, Entities뿐만 아니라 Authorize, Interactors 까지 의존하게 되어버립니다.

이는 다시 '숙취 증후군'의 경험을 일으킬 수 있고, 단위 테스트를 하고 릴리스를 하는 일도 어려워지게 됩니다.

그럼 이러한 의존성을 어떻게 끊어낼까요 ?

#### 순환 끊기

주요한 방법은 2가지가 있습니다.

1. 의존성 역전 원칙 (DIP)을 적용한다. User가 필요로 하는 메서드를 제공하는 인터페이스를 생성하고, 해당 인터페이스를 Entities에 위치시킨다.

![Alt text](image-2.png)

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스를 새로운 컴포넌트로 이동시킨다.

![Alt text](image-3.png)

이 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조 또한 변경되고 흐트러지게 된다는 것이다. 그러므로 의존성 구조에 순환이 발생하는 지 항상 관찰을 해야한다. 

### 하향식 설계
순환참조를 피하면서 개발을 하다보면 자연스럽게 하향식 설계를 할수 밖에 없습니다. 
컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화해야합니다. 

이에 대한 결론이 직관에서 어긋난다고 생각할 수 있지만, 컴포넌트 의존성 다이어그램은 사실상 기능을 기술하는 일과는 관련이 없습니다. 
오히려 **빌드 가능성**과 **유지 보수성**을 보여주는 지도와 같습니다. 

구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓여가면서 '숙취 증후군'을 겪지 않고 프로젝트를 개발하기 위해서는 의존성 관리에 대한 요구가 점차 늘어나게 됩니다. 
이에 따라 컴포넌트 의존성 관리를 진행하게 되고, 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 됩니다. 

클래스를 설계하지 않은 채로 컴포넌트 의존성 구조를 설계하면 상당히 큰 실패를 맛볼 수 있습니다. 
공통 폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것입니다. 따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발 맞춰 성장하며 진화해야 합니다. 


### SDP : 안정된 의존성 원칙 
> 안전성의 방향으로( 더 안정된 쪽에 ) 의존하라.

변경이 쉽지 않은 컴포넌트(A)가 변동성이 큰 컴포넌트(B)를 의존하게 만들어서는 절대로 안됩니다.
(B가 변경되면, A도 변경되어야 할텐데 변경이 쉽지 않기 때문에 문제가 생길 수 있다.)
한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경하기 어려워지기 때문이다.


#### 안정성
> '쉽게 움직이지 않는' 이라는 의미 입니다.

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 여러 요인( 크기, 복잡도, 간결함 등..)이 중 가장 확실한 방법 중 하나는 **수 많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것** 입니다.

<img width="718" alt="image" src="https://github.com/juyi212/Note/assets/57897408/fa4bd233-56e2-44db-a66f-d63e409cff26">

- 세 컴포넌트가 X에 의존하며, X는 변경하지 말아야 할 이유가 3가지가 된다. 이 경우 'X는 세 컴포넌트를 책임진다'라고 말한다.
- 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 없다. 이 경우, 'X는 독립적이다.'라고 말한다.
- 그림을 반대로 놓고 X가 세 컴포넌트에 의존적이라면 ? X가 변경될 수 있는 외부 요인은 3가지가 되는 것이다.

물론, 모든 컴포넌트가 안정적이어야 하는 것은 아닙니다. 
모든 컴포넌트가 안정적이라면 아무것도 변경할 수 없습니다. 다만, 변경 가능한 컴포넌트가 안정된 컴포넌트에 의존할 수 있도록 하는 것이 베스트 라는 것이죠 ! 

### SAP : 안정된 추상화 원칙 
> 컴포넌트는 안정된 정보만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?
시스템에서는 자주 변경되서는 안되는 영역이 있는데, 그 영역이 고수준 아키텍처나 정책 결정과 관련된 소프트웨어이다.
하지만, 이 고수준의 정책을 안정된 컴포넌트에 위치시키면 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 
이로 인해 시스템 전체 아키텍처가 유연성을 잃게 된다. 
그럼, 최고로 안정적이면서도 유연성일 잃지않게 하는 방법은 무엇일까? '개방 폐쇄 원칙(OCP)'를 활용하는 것이다.
OCP 에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다. 추상(abstract) 클래스가 이 원칙을 준수한다.

#### 안정된 추상화 원칙 
> 안정성과 추상화 정도 사이의 관계를 정의합니다.
이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 이야기 합니다. 

SAP와 SDP를 합치면 컴포넌트에 대한 DIP가 됩니다. 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있습니다.




생각 ) 
- 이번에 배운 개념들은 다 설계원칙과 비슷한 개념이라고 느꼈고, Javascript 동적 타입언어를 쓰는 React에서는 한번 더 이전에 배운 설계원칙을 준수해야한다는 개념으로 받아드리게 되었습니다. 여러분은 이번 개념을 배우고 어떤 생각을 하셨나요 ?


참고 자료 ) 
- 응집도 관련 영상 : https://www.youtube.com/watch?v=aSAGOH2u2rs









