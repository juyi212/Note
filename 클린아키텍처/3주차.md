# 컴포넌트 응집도

### REP : 재사용 / 릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다.

아키텍처의 관점에서 단일 컴포넌트는 응집성 높은 클래스 & 모듈로 구성되어야 한다.

즉, 공유하는 중요한 테마나 목적이 같은 것끼리 구성되어야한다는 뜻이다.

### CCP : 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이 원칙은 단일 책임 원칙 SRP 를 컴포넌트 관점에서 다시 쓴 것이다.
CCP에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.

애플리케이션 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기 보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

따라서 CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳(하나의 컴포넌트로)으로 묶을 것을 권한다.

### CRP : 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

공통 재사용 원칙 CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다. 같이 재사용되는 경향이 있는 클래스와 모듈들을 같은 컴포넌트에 포함해야 한다고 말한다.

재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.

예시) container와 iterator - 이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다. 따라서 동일한 컴포넌트에 위치해야한다.

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에 의존성이 생긴다.

사용하는 클래스에서 사용되는 클래스에서 단 하나의 클래스만 사용한다고 해도 의존성은 약해지지 않는다.

이런 의존성으로 인해 사용되는 컴포넌트가 변경될 때 마다 사용하는 컴포넌트도 변경해야할 가능성이 높다.

따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

**CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.**

<ISP와의 관계>

CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.
ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다.

CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 한다.

### 컴포넌트 응집도에 대한 균형 다이어그램

![Alt text](image.png)

- REP, CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미침
- CCP, REP에만 중점을 두면, 불필요한 릴리스가 너무 빈번해짐
  프로젝트 초기에는 CCP가 REP보다 훨씬 중요한데, 이는 개발 가능성이 재사용성보다 더욱 중요하기 때문입니다.

프로젝트가 성숙하고 해당 프로젝트로 부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동해 갑니다.

즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다는 뜻입니다.


# 컴포넌트 결합

### ADP: 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

'숙취증후군' : 내가 의존하고 있는 무언가가 수정이 되어서 작동하던 프로그램이 돌아가지 않는다. 😵

이를 해결하기 위한 2가지 방안이 있다.

1. 주단위 빌드
2. 의존성 비순환 원칙

#### 주 단위 빌드
- 5일 중 4일 동안 개발자가 각자 개발하고 하루에 몰아서 통합 및 빌드를 진행한다.
- 장점 : 빠른 피드백, 고립된 환경에서의 개발
- 단점 : 통합과 테스트를 수행하기 점점 어려워 짐.

#### 의존성 비순환 원칙
개발환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것입니다. <br>
이후 릴리스 번호를 부여하여 다른 팀에서 사용할 수 있도록 만듭니다. <br>
그런 다음 각 개발팀은 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정하고, 다른 팀에서는 릴리스 된 버전을 사용하면 됩니다. <br>
새로운 버전이 나와도 다른 팀들은 버전을 통합할지 자유롭게 결정이 가능하여, 컴포넌트의 변경이 다른 팀들에게 바로 영향을 주지 않습니다.
하지만!! 이렇게 사용하기 위해서는 의존성 구조를 잘 관리 하여야 합니다. <br>
즉, 순환되는 구조가 없도록 잘 관리되어야 합니다.

![Alt text](image2.png)

위의 그림은 '비순환 방향 그래프'로 어느 컴포넌트에서 시작하더라도 최초 컴포넌트로 돌아갈 수 없는 구조입니다.
위와 같은 구조의 릴리즈는 상향식으로 진행하면 됩니다.

#### 순환이 컴포넌트 의존성에 미치는 영향

![Alt text](image-1.png)
만약 순환이 생긴다면 ? <br>
위 그림에서 Entities에 포함된 클래스 하나가 Authorize에 포함된 클래스 하나를 사용하도록 변경하였습니다.<br>
이때 순환 의존성이 발생하게 됩니다. <br>
만약 Database를 릴리즈하려고 하면, Entities뿐만 아니라 Authorize, Interactors 까지 의존하게 되어버립니다. <br>
이는 다시 '숙취 증후군'의 경험을 일으킬 수 있고, 단위 테스트를 하고 릴리스를 하는 일도 어려워지게 됩니다.<br> 
그럼 이러한 의존성을 어떻게 끊어낼까요 ?

#### 순환 끊기

주요한 방법은 2가지가 있습니다.
1. 의존성 역전 원칙 (DIP)을 적용한다. User가 필요로 하는 메서드를 제공하는 인터페이스를 생성하고, 해당 인터페이스를 Entities에 위치시킨다.

![Alt text](image-2.png)

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스를 새로운 컴포넌트로 이동시킨다.

![Alt text](image-3.png)

이 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조 또한 변경되고 흐트러지게 된다는 것이다. 그러므로 의존성 구조에 순환이 발생하는 지 항상 관찰을 해야한다. 

### 하향식 설계 <정리 조금 더 필요>
순환참조를 피하면서 개발을 하다보면 자연스럽게 하향식 설계를 할수 밖에 없습니다. <br>
컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화해야합니다. <br>

이에 대한 결론이 직관에서 어긋난다고 생각할 수 있지만, 컴포넌트 의존성 다이어그램은 사실상 기능을 기술하는 일과는 관련이 없습니다.<br> 
오히려 **빌드 가능성**과 **유지 보수성**을 보여주는 지도와 같습니다. <br>

구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓여가면서 '숙취 증후군'을 겪지 않고 프로젝트를 개발하기 위해서는 의존성 관리에 대한 요구가 점차 늘어나게 됩니다. <br>
이에 따라 컴포넌트 의존성 관리를 진행하게 되고, 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 됩니다. <br>

클래스를 설계하지 않은 채로 컴포넌트 의존성 구조를 설계하면 상당히 큰 실패를 맛볼 수 있습니다. 
공통 폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것입니다. 따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발 맞춰 성장하며 진화해야 합니다. 


### SDP : 안정된 의존성 원칙 
> 안전성의 방향으로( 더 안정된 쪽에 ) 의존하라.

변경이 쉽지 않은 컴포넌트(A)가 변동성이 큰 컴포넌트(B)를 의존하게 만들어서는 절대로 안됩니다.
(B가 변경되면, A도 변경되어야 할텐데 변경이 쉽지 않기 때문에 문제가 생길 수 있다.)
한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경하기 어려워지기 때문이다.


#### 안정성
> '쉽게 움직이지 않는' 이라는 의미 입니다.

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 여러 요인( 크기, 복잡도, 간결함 등..)이 중 가장 확실한 방법 중 하나는 **수 많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것** 입니다.

<img width="718" alt="image" src="https://github.com/juyi212/Note/assets/57897408/fa4bd233-56e2-44db-a66f-d63e409cff26">

- 세 컴포넌트가 X에 의존하며, X는 변경하지 말아야 할 이유가 3가지가 된다. 이 경우 'X는 세 컴포넌트를 책임진다'라고 말한다.
- 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 없다. 이 경우, 'X는 독립적이다.'라고 말한다.
- 그림을 반대로 놓고 X가 세 컴포넌트에 의존적이라면 ? X가 변경될 수 있는 외부 요인은 3가지가 되는 것이다.

물론, 모든 컴포넌트가 안정적이어야 하는 것은 아닙니다. 
모든 컴포넌트가 안정적이라면 아무것도 변경할 수 없습니다. 다만, 변경 가능한 컴포넌트가 안정된 컴포넌트에 의존할 수 있도록 하는 것이 베스트 라는 것이죠 ! 

### SAP : 안정된 추상화 원칙 
> 컴포넌트는 안정된 정보만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?
시스템에서는 자주 변경되서는 안되는 영역이 있는데, 그 영역이 고수준 아키텍처나 정책 결정과 관련된 소프트웨어이다.
하지만, 이 고수준의 정책을 안정된 컴포넌트에 위치시키면 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 
이로 인해 시스템 전체 아키텍처가 유연성을 잃게 된다. 

그럼, 최고로 안정적이면서도 유연성일 잃지않게 하는 방법은 무엇일까? '개방 폐쇄 원칙(OCP)'를 활용하는 것이다.
OCP 에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다. 추상(abstract) 클래스가 이 원칙을 준수한다.

#### 안정된 추상화 원칙 
> 안정성과 추상화 정도 사이의 관계를 정의합니다.

이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 이야기 합니다. 
안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 합니다.안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 됩니다.

SDP는 의존성이 반드시 안정된 방향으로 향해야 한다고 말하고, 
SAP는 안정성이 결국 추상화를 의미한다고 말합니다. 따라서, 의존성은 추상화의 방향으로 흐르게 됩니다.
SAP(안정된 추상화 원칙)와 SDP(안정된 의존성 원칙)를 합치면 컴포넌트에 대한 DIP(의존성 역전 원칙)가 되며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있습니다.

#### 추상화 정도 측정하기 
<img width="369" alt="image" src="https://github.com/juyi212/Note/assets/57897408/a7d2fc16-f82b-401c-bba2-7a23996755aa">

- Nc: 컴포넌트의 클래스 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스 개수
- A: 추상화 정도, A = Na / Nc
- I: 불안정성, I = Fan out / (Fan-in + Fan-out)

모든 클래스가 "(0,1) 안정적,추상적"인 위치나 "(1,0)불안정, 구체적" 위치에 올 수 없습니다.<br>
여기서 가장 좋은 것은 주계열 부분에 위치하도록 만드는 것입니다.<br>
되도록이면 "쓸모없는 지역"과 "고통의 지역"은 배제하는 것이 좋습니다.<br>

#### 고통의 지역 
이 지역은 안정적이고 구체적인 영역으로 뻣뻣한 상태이다. 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 어렵다. 
ex) DB의 엔티티나 사용하는 라이브러리가 여기에 해당된다. DB의 엔티티는 변경 가능성이 커서 고통스럽지만, 라이브러리는 보통 변동성이 크지 않다. 

#### 쓸모없는 지역 
A (추상화 정도)가 크면서 I (불안정성)도 큰 컴포넌트이다. 만약 여러분이 인터페이스를 정의했는데, 참조하는 컴포넌트가 없다면? 추상화를 한 의미가 있을까? 

#### 주계열과의 거리 
배제 구역으로부터 최대한 멀리 떨어진 점의 궤적이 (0,1) (1,0)을 잇는 선분이다. 이를 주계열이라고 한다.<br>
이 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 '너무 추상적'이지도 않고, 추상화 정도에 비해 '너무 불안정'하지도 않다. <br>

그럼 이 주계열 선 근처에 있는 나의 위치와의 거리는 어떻게 측정할까?
- D : 거리, D = |A+I-1| 
이 거리로 해당 컴포넌트가 이상적인 직선에 가까운지, 아니면 배제되어야하는 영역과 가까운지를 알 수 있을 것이다.

#### 결론
지표는 신이 아니다. 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않는다. 이러한 지표는 아무리 해도 불완전하고, 예외는 항상 존재한다. 


생각 ) 
- 이번에 배운 개념들이 이전 시간에 배운 클래스의 설계 원칙과 비슷한 개념이지만, 이는 기능에 대한 단위를 만들 때를 보는게 아니라 더 큰 범주에서 유지 보수성에 대한 얘기를 조금 더 시사하는 거 같습니다. 우리가 유지 보수성을 지키기위해 해본 일들이 무엇이 있을까요 ? 


참고 자료 ) 
- 응집도 관련 영상 : https://www.youtube.com/watch?v=aSAGOH2u2rs
- https://techblog.woowahan.com/2561/









