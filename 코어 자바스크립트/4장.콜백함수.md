### 콜백함수

: 콜백 함수는 다른 함수 또는 메서드에게 인자로 넘겨주면서 제어권도 함께 위임한 함수를 의미합니다. 일반적으로 다른 함수의 작업이 끝나면 실행되는 함수이며, 비동기나 복잡한 작업 환경에서 유용하게 사용됩니다.

> 정확하게는 함수 A의 제어권을 다른 함수(메소드 포함) B에게 넘겨주었을 때 이 A함수를 콜백함수라고 한다는 것이다. 때문에 A함수는 B함수의 내부 로직에 따라 실행되며 this도 B함수 내부 로직에 의해 결정된다. 만약 B함수에서 A함수의 this를 별도 지정한다면 그게 A함수의 this가 된다.

[호출시점]

- 콜백 함수 A의 호출 시점은 함수 B가 결정한다.
- ex) setInterval

[인자]

- 콜백 함수 A의 인자로 넘겨줄 값과 그 순서도 함수 B가 결정한다.

[this]

- 콜백 함수 A의 this 또한 함수 B가 결정할 수 있다.

### 콜백함수도 함수다

콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출된다.

```javascript
// 메서드를 콜백 함수로 전달한 경우
var obj = {
  vals: [1, 2, 3],
  logValues: function (v, i) {
    console.log(this, v, i);
  },
};
obj.logValues(1, 2); // (1) { vals: [1, 2, 3], logValues: f } 1 2
[4, 5, 6].forEach(obj.logValues); // (2) Window { ... } 4 0
// Window { ... } 5 1
// Window { ... } 6 2
```

(2) : logValues 메서드를 forEach 함수의 콜백 함수로서 전달했다. obj를 this로 하는 메서드를 그대로 전달한 것이 아니라, obj.logValues가 가리키는 함수만 전달한 것이다. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어진다.

이 함수는 forEach에 의해 콜백이 함수로서 호출되고, 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 바라본다.

즉, 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다.

### 콜백 함수 내부의 this에 다른 값 바인딩하기

객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없다. 그럼에도 콜백 함수 내부에서 this가 객체를 바라보게 하는 방법은 무엇일까?

전통적인 방법으로는

> this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만다는 방식이 많이 사용되었다.

```javascript
// 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식
var obj1 = {
  name: "obj1",
  func: function () {
    var self = this;
    return function () {
      console.log(self.name);
    };
  },
};
var callback = obj1.func();
setTimeout(callback, 1000);
```

- obj1.func 메서드 내부에서 self 변수에 this를 담고, 익명 함수를 선언과 동시에 반환한다.
- obj1.func를 호출하면 앞서 선언한 내부 함수가 반환되어 callback 변수에 담긴다.
- callback을 setTimeout 함수에 인자로 전달하면 1초 뒤 callback이 실행되면서 obj1을 출력한다.

```javascript
// 콜백 함수 내부에서 this를 사용하지 않은 경우
var obj1 = {
  name: "obj1",
  func: function () {
    console.log(obj1.name);
  },
};
setTimeout(obj1.func, 1000);
```

이는 앞선 예제에서 this를 사용하지 않았을 때 결과입니다.
간결하지만, 다양한 상황에서 재활용할수는 없습니다. (처음부터 명시적으로 obj1을 바라보도록 설정하였기 때문)
우회적으로 돌리는 방법은 있지만, 귀찮습니다. 이를 대안하는 방법이 최근 ES5에 등장한 bind를 활용한 방법입니다.

```javascript
// 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용
var obj1 = {
  name: "obj1",
  func: function () {
    console.log(this.name);
  },
};
setTimeout(obj1.func.bind(obj1), 1000);

var obj2 = { name: "obj2" };
setTimeout(obj1.func.bind(obj2), 1500);
```

### 클로저 활용 사례

1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 (고차함수 활용)

```javascript
var alertFruit = function (fruit: string) {
  return function () {
    alert("your choice is" + fruit);
  };
};
fruits.forEach(function (fruit) {
  var $li = document.createElement("li");
  $li.innerText = fruit;
  $li.addEventListner("click", alertFruit(fruit));
  $ul.appendChild($li);
});
```

추후 언젠가 클릭 이벤트가 발생하면 비로소 이 함수의 실행 컨텍스트가 열리면서 alertFruit 의 인자로 넘어온 fruit를 outerEnvironmentReference에 의해 참조할 수 있게 됩니다. 즉, alertFruit의 반환된 함수에서 클로저가 존재하게 됩니다.

2. 접근 권한 제어 (정보은닉)

클로저를 활용하면 public(외부 접근 가능), private(내부에서만 사용, 외부에서 노출하지 않는 것) 한 값을 구분하는 것이 가능하다.

```javascript
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  return inner; // (1)
};

const outer2 = outer();
console.log(outer2());
console.log(outer2());
```

- outer 함수를 종료할 떄, inner 함수를 반환함으로써 outer 함수의 지역 변수인 a의 값을 외부에서도 읽을 수 있음
- 즉, return 을 활용해 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부의 변수에 대한 접근 권한을 부여 가능

### 부분 적용 함수 1)

```javascript
const partial = function () {
  const originalPartialArgs = arguments;
  const func = originalPartialArgs[0];
  if (typeof func !== "function") {
    throw new Error("첫 번째 인자가 함수가 아닙니다.");
  }
  return function () {
    // 외부함수의 areguments를 함수 빼고 두 번째 인자부터 배열로 만듬

    // 첫 번째 인자 배열 ex) [1,2,3,4,5]
    const partialArgs = Array.prototype.slice.call(originalPartialArgs, 1);

    // 두 번째 인자 배열
    const restArgs = Array.prototype.slice.call(arguments); // 현재 함수의 arguments

    return func.apply(this, partialArgs.concat(restArgs)); // 인자를 합쳐서 func 실행
    // 여러 개의 인자들을 하나의 배열로 보냄(apply) func에서는 배열 자체가 아니라 배열 속 원소들을 인자로 받음
  };
};

const add = function () {
  let result = 0;
  for (let i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }
  return result;
};

const addPartial = partial(add, 1, 2, 3, 4, 5);
console.log(addPartial(6, 7, 8, 9, 10)); // 55
```

- 함수를 선언할 당시의 인자들을 변수에 담아두고 기억해두었다가, 반환되는 함수가 호출될 때 클로저를 활용해서 이전에 선언했던 변수들과 함께 사용하게 됨

### 부분 적용 함수 2)
