### 콜백함수

: 콜백 함수는 다른 함수 또는 메서드에게 인자로 넘겨주면서 제어권도 함께 위임한 함수를 의미합니다. 일반적으로 다른 함수의 작업이 끝나면 실행되는 함수이며, 비동기나 복잡한 작업 환경에서 유용하게 사용됩니다.

> 정확하게는 함수 A의 제어권을 다른 함수(메소드 포함) B에게 넘겨주었을 때 이 A함수를 콜백함수라고 한다는 것이다. 때문에 A함수는 B함수의 내부 로직에 따라 실행되며 this도 B함수 내부 로직에 의해 결정된다. 만약 B함수에서 A함수의 this를 별도 지정한다면 그게 A함수의 this가 된다.

[호출시점]

- 콜백 함수 A의 호출 시점은 함수 B가 결정한다.
- ex) setInterval

[인자]

- 콜백 함수 A의 인자로 넘겨줄 값과 그 순서도 함수 B가 결정한다.

[this]

- 콜백 함수 A의 this 또한 함수 B가 결정할 수 있다.

### 콜백함수도 함수다

콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출된다.

```javascript
// 메서드를 콜백 함수로 전달한 경우
var obj = {
  vals: [1, 2, 3],
  logValues: function (v, i) {
    console.log(this, v, i);
  },
};
obj.logValues(1, 2); // (1) { vals: [1, 2, 3], logValues: f } 1 2
[4, 5, 6].forEach(obj.logValues); // (2) Window { ... } 4 0
// Window { ... } 5 1
// Window { ... } 6 2
```

(2) : logValues 메서드를 forEach 함수의 콜백 함수로서 전달했다. obj를 this로 하는 메서드를 그대로 전달한 것이 아니라, obj.logValues가 가리키는 함수만 전달한 것이다. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어진다.

이 함수는 forEach에 의해 콜백이 함수로서 호출되고, 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 바라본다.

즉, 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다.

### 콜백 함수 내부의 this에 다른 값 바인딩하기

객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없다. 그럼에도 콜백 함수 내부에서 this가 객체를 바라보게 하는 방법은 무엇일까?

전통적인 방법으로는

> this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만다는 방식이 많이 사용되었다.

```javascript
// 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식
var obj1 = {
  name: "obj1",
  func: function () {
    var self = this;
    return function () {
      console.log(self.name);
    };
  },
};
var callback = obj1.func();
setTimeout(callback, 1000);
```

- obj1.func 메서드 내부에서 self 변수에 this를 담고, 익명 함수를 선언과 동시에 반환한다.
- obj1.func를 호출하면 앞서 선언한 내부 함수가 반환되어 callback 변수에 담긴다.
- callback을 setTimeout 함수에 인자로 전달하면 1초 뒤 callback이 실행되면서 obj1을 출력한다.

```javascript
// 콜백 함수 내부에서 this를 사용하지 않은 경우
var obj1 = {
  name: "obj1",
  func: function () {
    console.log(obj1.name);
  },
};
setTimeout(obj1.func, 1000);
```

이는 앞선 예제에서 this를 사용하지 않았을 때 결과입니다.
간결하지만, 다양한 상황에서 재활용할수는 없습니다. (처음부터 명시적으로 obj1을 바라보도록 설정하였기 때문)
우회적으로 돌리는 방법은 있지만, 귀찮습니다. 이를 대안하는 방법이 최근 ES5에 등장한 bind를 활용한 방법입니다.

```javascript
// 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용
var obj1 = {
  name: "obj1",
  func: function () {
    console.log(this.name);
  },
};
setTimeout(obj1.func.bind(obj1), 1000);

var obj2 = { name: "obj2" };
setTimeout(obj1.func.bind(obj2), 1500);
```

### 클로저 활용 사례

1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 (고차함수 활용)

```javascript
var alertFruit = function (fruit: string) {
  return function () {
    alert("your choice is" + fruit);
  };
};
fruits.forEach(function (fruit) {
  var $li = document.createElement("li");
  $li.innerText = fruit;
  $li.addEventListner("click", alertFruit(fruit));
  $ul.appendChild($li);
});
```

추후 언젠가 클릭 이벤트가 발생하면 비로소 이 함수의 실행 컨텍스트가 열리면서 alertFruit 의 인자로 넘어온 fruit를 outerEnvironmentReference에 의해 참조할 수 있게 됩니다. 즉, alertFruit의 반환된 함수에서 클로저가 존재하게 됩니다.

2. 접근 권한 제어 (정보은닉)

클로저를 활용하면 public(외부 접근 가능), private(내부에서만 사용, 외부에서 노출하지 않는 것) 한 값을 구분하는 것이 가능하다.

```javascript
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  return inner; // (1)
};

const outer2 = outer();
console.log(outer2());
console.log(outer2());
```

- outer 함수를 종료할 떄, inner 함수를 반환함으로써 outer 함수의 지역 변수인 a의 값을 외부에서도 읽을 수 있음
- 즉, return 을 활용해 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부의 변수에 대한 접근 권한을 부여 가능

### 부분 적용 함수 1)

```javascript
const partial = function () {
  const originalPartialArgs = arguments;
  const func = originalPartialArgs[0];
  if (typeof func !== "function") {
    throw new Error("첫 번째 인자가 함수가 아닙니다.");
  }
  return function () {
    // 외부함수의 areguments를 함수 빼고 두 번째 인자부터 배열로 만듬

    // 첫 번째 인자 배열 ex) [1,2,3,4,5]
    const partialArgs = Array.prototype.slice.call(originalPartialArgs, 1);

    // 두 번째 인자 배열
    const restArgs = Array.prototype.slice.call(arguments); // 현재 함수의 arguments

    return func.apply(this, partialArgs.concat(restArgs)); // 인자를 합쳐서 func 실행
    // 여러 개의 인자들을 하나의 배열로 보냄(apply) func에서는 배열 자체가 아니라 배열 속 원소들을 인자로 받음
  };
};

const add = function () {
  let result = 0;
  for (let i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }
  return result;
};

const addPartial = partial(add, 1, 2, 3, 4, 5);
console.log(addPartial(6, 7, 8, 9, 10)); // 55
```

- 함수를 선언할 당시의 인자들을 변수에 담아두고 기억해두었다가, 반환되는 함수가 호출될 때 클로저를 활용해서 이전에 선언했던 변수들과 함께 사용하게 됨

### 부분 적용 함수 2)

```javascript
Object.defineProperty(window, '_', {
 	value: 'EMPTY_SPACE',
  writable: false,
  configurable: false,
  enumerable: false
});

const partial12 = functino(){
  const originalPartialArgs = arguments;
  const func = originalPartialArgs[0];
  if(typeof func !== 'function'){
     throw new Error('첫 번째 인자가 함수가 아닙니다.');
  }
  return function(){
    const partialArgs = Array.prototype.slice.call(originalPartialArgs, 1);
    const restArgs =  Array.prototype.slice.call(arguments);

    // (**) 추가된 for문. 비어있으면(_) restArgs 인자들 차례대로 끼워 넣기
    for (var i = 0; i < partialArgs.length; i++){
      	if(partialArgs[i] === _) {
          partialArgs[i] = restArgs.shift();
        }
    }
    return func.apply(this, partialArgs.concat(restArgs));
  };
};

const addPartial2(add, 1,2,_,4,5,_,_,8,9);
console.log(addPartial(3,6,7,10)); //55
```

- 이번에는 '비워놓음'을 표시하기 위해 미리 전역객체에 '\_'라는 프로퍼티를 준비하면서 삭제 변경 등의 접근에 대한 방어 차원에서 여러 가지 프로퍼티 속성을 설정함.
- '\_' 에 추가된 부분을 보면 예시(1)과 차이가 있다. 처음에 넘겨준 인자들 중 '\_'로 비워놓은 공간마다 나중에 넘어온 인자들이 차례대로 끼워 들어가도록 구현했다.
- 부분 적용 함수를 만들 때 미리부터 실행할 함수의 모든 인자 개수를 맞춰 빈 공간을 확보하지 않아도 됨.

### 부분 적용 함수3) 디바운스

```javascript
const debounce = function (eventName, func, wait) {
  let timeoutId = null;
  return function (event) {
    const self = this;
    console.log(eventName, "event 발생");
    clearTimeout(timeoutId); // (2)
    timeoutId = setTimeout(func.bind(self, event), wait); // (1)
  };
};

const moveHandler = function (e) {
  console.log("move event 처리");
  console.dir(e); // MouseEvent 객체
};

const wheelHandler = function (e) {
  console.log("wheel event 처리");
};

//이벤트가 발생하면 debounce 함수가 실행되고, 내부함수를 리턴, 반환된 내부함수가 이벤트 핸들러가 된다.
document.body.addEventListener("mouse", debounce("move", moveHandler, 500));
document.body.addEventListener("mouse", debounce("move", moveHandler, 700));
```

- (1) 최초 이벤트가 발생하면 (1)코드에 의해 timeout의 대기열에 'wait 시간 뒤에 func를 실행할 것'이라는 내용이 담긴다.
- 그런데 wait 시간이 경과하기 이전에 다시 동일한 event가 발생하면 이번에는 (2)에 의해 앞서 저장했던 대기열을 초기화하고, 다시 (1)번째 줄에서 새로운 대기열을 등록한다. 결국 각 이벤트가 바로 이전 이벤트로부터 wait 시간 이내에 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 무사히 실행될 것이다.
- 참고로, 해당 예제의 디바운스 함수에서 클로저로 처리되는 변수에는 eventName, func, wait, timeoutId가 있음
- 결과: 실제 이벤트 발생(wait시간 내)은 여러번이지만 이벤트 발생에 따른 콜백함수 실행은 한 번씩 된다.
